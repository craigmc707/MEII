#include <MEL/Daq/Quanser/Q8Usb.hpp>
#include <MEII/MahiExoII/MahiExoII.hpp>
#include <MEL/Utility/System.hpp>
#include <MEL/Communications/MelShare.hpp>
#include <MEL/Utility/Options.hpp>
#include <MEL/Core/Timer.hpp>
#include <MEL/Core/Console.hpp>
#include <MEL/Math/Functions.hpp>
#include <MEL/Logging/Log.hpp>
#include <MEL/Logging/Csv.hpp>
#include <MEL/Devices/Windows/Keyboard.hpp>
#include <MEII/Control/Trajectory.hpp>
#include <MEII/Control/DynamicMotionPrimitive.hpp>
#include <MEII/Control/MinimumJerk.hpp>
#include <MEL/Math/Integrator.hpp>
#include <vector>

using namespace mel;
using namespace meii;


// create global stop variable CTRL-C handler function
ctrl_bool stop(false);
bool handler(CtrlEvent event) {
	stop = true;
	return true;
}

void next_state(int& current_state_, WayPoint current_position_, WayPoint new_position_, Time traj_length_, DynamicMotionPrimitive& dmp_, Timer ref_traj_clock_){
    current_position_.set_time(seconds(0));
    new_position_.set_time(seconds(0));
    dmp_.set_endpoints(current_position_, new_position_);
    if (!dmp_.trajectory().validate()) {
        LOG(Warning) << "DMP trajectory invalid.";
        stop = true;
    }
    current_state_++;
    ref_traj_clock_.restart();
}

int main(int argc, char *argv[]) {

    // register ctrl-c handler
	register_ctrl_handler(handler);

	// make options
	Options options("ex_pos_control_nathan.exe", "Nathan's Position Control Demo");
	options.add_options()
		("c,calibrate", "Calibrates the MAHI Exo-II")
		("s,single", "MAHI Exo-II follows a single-DoF trajectory generated by a DMP")
		("m,multi", "MAHI Exo-II follows a multi-DoF trajectory generated by a DMP")
		("i,int", "Enter an interger", value<int>())
		("h,help", "Prints this help message");

	auto result = options.parse(argc, argv);

	// if -h, print the help option
	if (result.count("help") > 0) {
		print(options.help());
		return 0;
	}
    /////////////////////////////////
	// construct Q8 USB and configure
    /////////////////////////////////
	Q8Usb q8;
	q8.open();
	q8.DO.set_enable_values(std::vector<Logic>(8, High));
	q8.DO.set_disable_values(std::vector<Logic>(8, High));
	q8.DO.set_expire_values(std::vector<Logic>(8, High));
	
    Time Ts = milliseconds(1); // sample period for DAQ

    ////////////////////////////////

    //////////////////////////////////////////////
	// create MahiExoII and bind Q8 channels to it
    //////////////////////////////////////////////

	std::vector<Amplifier> amplifiers;
	std::vector<double> amp_gains;
	for (uint32 i = 0; i < 2; ++i) {
		amplifiers.push_back(
			Amplifier("meii_amp_" + std::to_string(i),
				Low,
				q8.DO[i + 1],
				1.8,
				q8.AO[i + 1])
		);
	}
	for (uint32 i = 2; i < 5; ++i) {
		amplifiers.push_back(
			Amplifier("meii_amp_" + std::to_string(i),
				Low,
				q8.DO[i + 1],
				0.184,
				q8.AO[i + 1])
		);
	}
	MeiiConfiguration config(q8, q8.watchdog, q8.encoder[{1, 2, 3, 4, 5}], amplifiers);
	MahiExoII meii(config);

	bool rps_is_init = false;

    //////////////////////////////////////////////

	// calibrate - manually zero the encoders (right arm supinated)
	if (result.count("calibrate") > 0) {
		meii.calibrate_auto(stop);
		LOG(Info) << "MAHI Exo-II encoders calibrated.";
		return 0;
	}

	// make MelShares
	MelShare ms_pos("ms_pos");
	MelShare ms_vel("ms_vel");
	MelShare ms_trq("ms_trq");
	MelShare ms_ref("ms_ref");

	// create ranges for saturating trajectories for safety    MIN            MAX
	std::vector<std::vector<double>> setpoint_rad_ranges = { { -90 * DEG2RAD, 0  * DEG2RAD },
                                                             { -90 * DEG2RAD, 90 * DEG2RAD },
                                                             { -15 * DEG2RAD, 15 * DEG2RAD },
                                                             { -15 * DEG2RAD, 15 * DEG2RAD },
                                                             { 0.08,          0.115 } };

    enum state {
        neutral,           // 0
        to_bottom_elbow,   // 1
        to_top_elbow,      // 2
        to_neutral,        // 3
        to_top_wrist,      // 4
        wrist_circle,      // 5
        to_neutral_2       // 6
    };

    // setup trajectories
    
    // waypoints                                   Elbow F/E      Forearm P/S   Wrist F/E     Wrist R/U     LastDoF
    WayPoint neutral_point = WayPoint(Time::Zero,{ -35 * DEG2RAD, 00 * DEG2RAD, 00 * DEG2RAD, 00 * DEG2RAD, 0.09 });
    WayPoint bottom_elbow  = WayPoint(Time::Zero,{ -65 * DEG2RAD, 00 * DEG2RAD, 00 * DEG2RAD, 00 * DEG2RAD, 0.09 });
    WayPoint top_elbow     = WayPoint(Time::Zero,{ -35 * DEG2RAD, 00 * DEG2RAD, 00 * DEG2RAD, 00 * DEG2RAD, 0.09 });
    WayPoint top_wrist     = WayPoint(Time::Zero,{ -35 * DEG2RAD, 00 * DEG2RAD, 00 * DEG2RAD, 00 * DEG2RAD, 0.09 });

	// construct timer in hybrid mode to avoid using 100% CPU
	Timer timer(Ts, Timer::Hybrid);
	timer.set_acceptable_miss_rate(0.05);

	// construct clock for regulating keypress
	Clock keypress_refract_clock;
	Time keypress_refract_time = seconds(0.5);

	std::vector<std::string> dof_str = { "ElbowFE", "WristPS", "WristFE", "WristRU" };

	// trajectory following
	if (result.count("single") > 0) {
		LOG(Info) << "Starting Movement.";
		
        while(!stop){
			
			// update all DAQ output channels
			q8.update_output();

			// check for save key
			if (Keyboard::is_key_pressed(Key::Enter) || Keyboard::is_key_pressed(Key::Escape)) {
				stop = true;
			}

			// kick watchdog
			if (!q8.watchdog.kick() || meii.any_limit_exceeded()) {
				stop = true;
			}

			// wait for remainder of sample period
			timer.wait();
		}

		meii.disable();
        q8.disable();
	}

	Keyboard::clear_console_input_buffer();
	return 0;
}