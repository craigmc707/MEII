#include <MEII/Control/DynamicMotionPrimitive.hpp>
#include <MEII/Control/MinimumJerk.hpp>
#include <MEII/Control/Trajectory.hpp>
#include <MEII/MahiExoII/MahiExoII.hpp>
#include <MEL/Communications/MelShare.hpp>
#include <MEL/Core/Console.hpp>
#include <MEL/Core/Timer.hpp>
#include <MEL/Daq/Quanser/Q8Usb.hpp>
#include <MEL/Devices/Windows/Keyboard.hpp>
#include <MEL/Logging/Csv.hpp>
#include <MEL/Logging/Log.hpp>
#include <MEL/Math/Functions.hpp>
#include <MEL/Math/Integrator.hpp>
#include <MEL/Utility/Options.hpp>
#include <MEL/Utility/System.hpp>
#include <vector>

using namespace mel;
using namespace meii;

enum state {
    to_neutral_0,     // 0
    to_bottom_elbow,  // 1
    to_top_elbow,     // 2
    to_neutral_1,     // 3
    to_top_wrist,     // 4
    wrist_circle,     // 5
    to_neutral_2      // 6
};

// create global stop variable CTRL-C handler function
ctrl_bool stop(false);
bool handler(CtrlEvent event) {
    stop = true;
    return true;
}

void to_state(state& current_state_, const int next_state_, WayPoint current_position_, WayPoint new_position_, Time traj_length_, MinimumJerk& mj_, Clock& ref_traj_clock_) {
    // set the times for the current and new position to 0 and traj_length respectively
    current_position_.set_time(seconds(0));
    new_position_.set_time(traj_length_);
    
    // generate the new minimum jerk trajectory
    mj_.set_endpoints(current_position_, new_position_);
    if (!mj_.trajectory().validate()) {
        LOG(Warning) << "MJ trajectory invalid.";
        stop = true;
    }
    
    // iterate the state. can't iterate an enum, so this iterates
    current_state_ = static_cast<state>(next_state_);

    // restart the trajectory clock
    ref_traj_clock_.restart();
}

int main(int argc, char* argv[]) {
    // register ctrl-c handler
    register_ctrl_handler(handler);

    // make options
    Options options("ex_pos_control_nathan.exe", "Nathan's Position Control Demo");
    options.add_options()
		("c,calibrate", "Calibrates the MAHI Exo-II")
		("m,multi", "MAHI Exo-II follows a multi-DoF trajectory generated by mjs")
        ("n,no_torque", "trajectories are generated, but not torque provided")
		("h,help", "Prints this help message");

    auto result = options.parse(argc, argv);

    // if -h, print the help option
    if (result.count("help") > 0) {
        print(options.help());
        return 0;
    }
    /////////////////////////////////
    // construct Q8 USB and configure
    /////////////////////////////////
    Q8Usb q8;
    q8.open();
    q8.DO.set_enable_values(std::vector<Logic>(8, High));
    q8.DO.set_disable_values(std::vector<Logic>(8, High));
    q8.DO.set_expire_values(std::vector<Logic>(8, High));

    Time Ts = milliseconds(1);  // sample period for DAQ

    ////////////////////////////////

    //////////////////////////////////////////////
    // create MahiExoII and bind Q8 channels to it
    //////////////////////////////////////////////

    std::vector<Amplifier> amplifiers;
    for (uint32 i = 0; i < 2; ++i) {
        amplifiers.push_back(
            Amplifier("meii_amp_" + std::to_string(i),
                      Low,
                      q8.DO[i + 1],
                      1.8,
                      q8.AO[i + 1]));
    }
    for (uint32 i = 2; i < 5; ++i) {
        amplifiers.push_back(
            Amplifier("meii_amp_" + std::to_string(i),
                      Low,
                      q8.DO[i + 1],
                      0.184,
                      q8.AO[i + 1]));
    }
    MeiiConfiguration config(q8, q8.watchdog, q8.encoder[{1, 2, 3, 4, 5}], amplifiers);
    MahiExoII meii(config);

    bool rps_is_init = false;

    //////////////////////////////////////////////

    // calibrate - manually zero the encoders (right arm supinated)
    if (result.count("calibrate") > 0) {
        meii.calibrate_auto(stop);
        LOG(Info) << "MAHI Exo-II encoders calibrated.";
        return 0;
    }

    // make MelShares
    MelShare ms_pos("ms_pos");
    MelShare ms_vel("ms_vel");
    MelShare ms_trq("ms_trq");
    MelShare ms_ref("ms_ref");

    // create ranges for saturating trajectories for safety  MIN            MAX
    std::vector<std::vector<double>> setpoint_rad_ranges = {{-90 * DEG2RAD, 0 * DEG2RAD},
                                                            {-90 * DEG2RAD, 90 * DEG2RAD},
                                                            {-10 * DEG2RAD, 10 * DEG2RAD},
                                                            {-10 * DEG2RAD, 10 * DEG2RAD},
                                                            {0.08, 0.115}};

    // setup variables needed to generate trajectories

    // initialize reference trajectory
    std::vector<double> ref(meii.N_aj_,0.0);

    // waypoints                                   Elbow F/E       Forearm P/S   Wrist F/E     Wrist R/U     LastDoF
    WayPoint neutral_point = WayPoint(Time::Zero, {-35 * DEG2RAD,  00 * DEG2RAD, 00  * DEG2RAD, 00 * DEG2RAD, 0.09});
    WayPoint bottom_elbow  = WayPoint(Time::Zero, {-65 * DEG2RAD,  45 * DEG2RAD, 00  * DEG2RAD, 00 * DEG2RAD, 0.09});
    WayPoint top_elbow     = WayPoint(Time::Zero, { -5 * DEG2RAD, -45 * DEG2RAD, 00  * DEG2RAD, 00 * DEG2RAD, 0.09});
    WayPoint top_wrist     = WayPoint(Time::Zero, {-35 * DEG2RAD,  00 * DEG2RAD, 00  * DEG2RAD, 10 * DEG2RAD, 0.09});

                                          // to_neutral   to bot_elbow  to top_elbow   to neutral     to top_wrist  doing circle   to neutral
    std::vector<Time>     state_times   = {seconds(5.0),  seconds(4.0), seconds(8.0), seconds(4.0),  seconds(3.0), seconds(6.0), seconds(5.0)};
    std::vector<WayPoint> WaypointOrder = {neutral_point, bottom_elbow, top_elbow,     neutral_point, top_wrist,    top_wrist,     neutral_point};

    // construct timer in hybrid mode to avoid using 100% CPU
    Timer timer(Ts, Timer::Hybrid);
    timer.set_acceptable_miss_rate(0.05);

    // construct clock for regulating keypress
    Clock keypress_refract_clock;
    Time keypress_refract_time = seconds(0.5);

    std::vector<std::string> dof_str = {"ElbowFE", "WristPS", "WristFE", "WristRU"};

    ////////////////////////////////////////////////
    //////////// State Manager Setup ///////////////
    ////////////////////////////////////////////////

    // initialize to the first state
    state current_state = to_neutral_0;

    // initialize the minimum jerk trajectory and trajectory clock
    Time mj_Ts = milliseconds(20);
    MinimumJerk mj(mj_Ts, neutral_point, bottom_elbow.set_time(state_times[to_neutral_0]));
	std::vector<double> traj_max_diff = { 50 * mel::DEG2RAD, 50 * mel::DEG2RAD, 25 * mel::DEG2RAD, 25 * mel::DEG2RAD, 0.1 };
	mj.set_trajectory_params(Trajectory::Interp::Linear, traj_max_diff);
    Clock ref_traj_clock;

    mj.trajectory(); // THIS LINE SHOULDNT BE NEEDED...BUT IT IS IN HERE OR ELSE IT FAILS
    if (!mj.trajectory().validate()) {
        LOG(Warning) << "MJ trajectory invalid.";
        stop = true;
    }

    // initialize anatomical position and velocity vectors
    std::vector<double> aj_positions(meii.N_aj_,0.0);
    std::vector<double> aj_velocities(meii.N_aj_,0.0);

    // initialize command torque vectors
    std::vector<double> command_torques(meii.N_aj_,0.0);
    std::vector<double> rps_command_torques(3,0.0);
	
	// enable DAQ and exo
	q8.enable();
	meii.enable();
	
	q8.watchdog.start();

    // trajectory following
    if (result.count("multi") > 0 || result.count("no_torque") > 0) {
        LOG(Info) << "Starting Movement.";

        // update q8 values so that we can get meii kinematic values
        q8.update_input();

        // update MahiExoII kinematics
        meii.update_kinematics();

        // get starting position from the robot
        WayPoint start_pos(Time::Zero, meii.get_anatomical_joint_positions());

        // initialize endpoints moving from start position to neutral point
        mj.set_endpoints(start_pos, neutral_point.set_time(state_times[to_neutral_0]));

        // start the reference trajectory clock
        ref_traj_clock.restart();

        while (!stop) {
            // update all DAQ input channels
            q8.update_input();

            // update MahiExoII kinematics
            meii.update_kinematics();

            // update anatomical positions and velocities
            for (int i = 0; i < meii.N_aj_; ++i) {
                aj_positions[i] = meii.get_anatomical_joint_position(i);
                aj_velocities[i] = meii.get_anatomical_joint_velocity(i);
            }

            // for all states except when making a wrist circle
            if (current_state != wrist_circle) {
                // update reference from trajectory
                ref = mj.trajectory().at_time(ref_traj_clock.get_elapsed_time());
            } 
			else {
                // update reference to anatomical wrist FE and RU moving in a circle with others at neutral
                ref[0] = neutral_point.get_pos()[0];
                ref[1] = neutral_point.get_pos()[1];
                ref[2] = 10.0 * DEG2RAD * mel::sin(2.0 * PI * ref_traj_clock.get_elapsed_time() / state_times[wrist_circle]);
                ref[3] = 10.0 * DEG2RAD * mel::cos(2.0 * PI * ref_traj_clock.get_elapsed_time() / state_times[wrist_circle]);
                ref[4] = neutral_point.get_pos()[4];
            }

            // constrain trajectory to be within range
            for (std::size_t i = 0; i < meii.N_aj_; ++i) {
                ref[i] = saturate(ref[i], setpoint_rad_ranges[i][0], setpoint_rad_ranges[i][1]);
            }

            // calculate anatomical command torques
            command_torques[0] = meii.anatomical_joint_pd_controllers_[0].calculate(ref[0], aj_positions[0], 0, meii[0].get_velocity());
            command_torques[1] = meii.anatomical_joint_pd_controllers_[1].calculate(ref[1], aj_positions[1], 0, meii[1].get_velocity());
            for (std::size_t i = 0; i < meii.N_qs_; ++i) {
                rps_command_torques[i] = meii.anatomical_joint_pd_controllers_[i + 2].calculate(ref[i + 2], aj_positions[i + 2], 0, aj_velocities[i + 2]);
            }
            std::copy(rps_command_torques.begin(), rps_command_torques.end(), command_torques.begin() + 2);

            // if in the no-torque setting, set all command torques to 0
            if (result.count("no_torque") > 0){
                command_torques = {0.0, 0.0, 0.0, 0.0, 0.0};
            }
            
            // set anatomical command torques
            meii.set_anatomical_joint_torques(command_torques);

            // update all DAQ output channels
            q8.update_output();
            
            // if enough time has passed, continue to the next state, unless we are in final state. See to_state function at top of file for details
            if (ref_traj_clock.get_elapsed_time() > state_times[current_state]) {
                // if we are in the final state, stop the exo 
                if(current_state == to_neutral_2){
                    stop = true;
                    break;
                }
                // if we aren't in the final state, go to the next state
                else{    
                    to_state(current_state, (current_state+1), WaypointOrder[current_state], WaypointOrder[current_state+1], state_times[current_state+1], mj, ref_traj_clock);
                }
                
            }

            // write data to melshares
            ms_ref.write_data(ref);
            ms_pos.write_data(aj_positions);

            // check for save key
            if (Keyboard::is_key_pressed(Key::Enter) || Keyboard::is_key_pressed(Key::Escape)) {
                stop = true;
            }

            // kick watchdog
            if (!q8.watchdog.kick() || meii.any_limit_exceeded()) {
                print("Watchdog not kicked or limit exceeded");
                stop = true;
            }

            // wait for remainder of sample period
            timer.wait();
        }
        
        // disable meii and q8
        meii.disable();
        q8.disable();
    }

    Keyboard::clear_console_input_buffer();
    return 0;
}